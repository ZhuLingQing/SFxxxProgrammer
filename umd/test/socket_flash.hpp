#ifndef SOCKET_FLASH_HPP
#define SOCKET_FLASH_HPP

#include <arpa/inet.h>
#include <unistd.h>

#include <iostream>
#include <memory>
#include <string>

#include "flash_info.pb.h"  // protobuf generated by protoc

#include "dp_config.h"
#include "dp_error.h"
#include "dp_logging.hpp"
#include "dp_type.h"
#include "flash_database.hpp"
#include "flash_interface.hpp"

using PacketType = flash::PacketType;

namespace dp
{
class SocketFlash
{
   public:
    static int Factory(const std::string &db_file, const std::string &flash_name, int port)
    {
        auto sf = SocketFlash(db_file, flash_name, port);
        int r = sf.Start();
        if (r) return r;
        sf.Polling();
        return 0;
    }

   private:
    SocketFlash(const std::string &db_file, const std::string &flash_name, int port)
        : db_(FlashDatabase::getInstance(db_file)), skt_port_(port)
    {
        auto info = db_.getFlashInfo(flash_name);
        if (nullptr == info)
        {
            DP_LOG(ERROR) << "Flash " << flash_name << " is not found in flash database";
        }
        flash_info_ = info;
    }
    int Start()
    {
        if (flash_info_ == nullptr)
        {
            std::cerr << "invalid flash info";
            return 1;
        }
        // 创建套接字
        skt_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (skt_fd_ == -1)
        {
            std::cerr << "Failed to create socket\n";
            return 1;
        }

        // 绑定地址和端口
        sockaddr_in serverAddress{};
        serverAddress.sin_family = AF_INET;
        serverAddress.sin_addr.s_addr = INADDR_ANY;
        serverAddress.sin_port = htons(skt_port_);

        if (bind(skt_fd_, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1)
        {
            std::cerr << "Failed to bind socket\n";
            close(skt_fd_);
            return 1;
        }

        // 监听连接
        if (listen(skt_fd_, 5) < 0)
        {
            std::cerr << "Failed to listen on socket\n";
            close(skt_fd_);
            return 1;
        }
        // 接受客户端连接
        sockaddr_in clientAddress{};
        socklen_t clientAddressLength = sizeof(clientAddress);
        int clientSocket = accept(skt_fd_, (struct sockaddr *)&clientAddress, &clientAddressLength);
        if (clientSocket == -1)
        {
            std::cerr << "Failed to accept client connection\n";
            close(skt_fd_);
            return 1;
        }

        std::cout << "Client connected\n";
        return 0;
    }
    int Send(PacketType type, uint64_t attribute = 0)
    {
        flash::FlashCmdPkt pkt;
        pkt.set_type(type);
        pkt.set_attribute(attribute);

        std::string serializedData;
        pkt.SerializeToString(&serializedData);

        uint32_t dataLength = htonl(serializedData.size());
        send(skt_fd_, &dataLength, sizeof(dataLength), 0);

        send(skt_fd_, serializedData.data(), serializedData.size(), 0);
        return 0;
    }
    int Send(PacketType type, std::vector<uint8_t> &data)
    {
        flash::FlashCmdPkt pkt;
        pkt.set_type(type);
        if (data.size())
        {
            std::string byte_string;
            byte_string.assign(data.begin(), data.end());
            pkt.set_data(byte_string);
        }

        std::string serializedData;
        pkt.SerializeToString(&serializedData);

        uint32_t dataLength = htonl(serializedData.size());
        send(skt_fd_, &dataLength, sizeof(dataLength), 0);

        send(skt_fd_, serializedData.data(), serializedData.size(), 0);
        return 0;
    }
    int Read(flash::FlashCmdPkt &pkt)
    {
        uint32_t dataLength;
        recv(skt_fd_, &dataLength, sizeof(dataLength), 0);
        dataLength = ntohl(dataLength);  // 转换字节序

        char buffer[kMaxBufferSize];
        recv(skt_fd_, buffer, dataLength, 0);

        // flash::FlashCmdPkt pkt;
        if (pkt.ParseFromArray(buffer, dataLength))
        {
            // type = pkt.type();
            // attribute = pkt.attribute();
            // cs = pkt.cs();
            // std::string byte_string = pkt.data();
            // data = std::vector<uint8_t>(byte_string.begin(), byte_string.end());
            return 0;
        }
        else
        {
            DP_LOG(ERROR) << "Failed to parse Protobuf data";
            return -1;
        }
    }
    void Polling()
    {
        int r;
        flash::FlashCmdPkt pkt;
        while (1)
        {
            r = Read(pkt);
            if (r) break;
            auto x = kPacketHandlerMap.find(pkt.type());
            if (x == kPacketHandlerMap.end())
            {
                std::cerr << "Invalid packet type\n";
                break;
            }
            r = x->second(pkt);
            if (r) break;
        }
    }
    int skt_port_;
    int skt_fd_;
    static const size_t kMaxBufferSize = CONFIG_PROTO_BUFFER_SIZE;

    FlashDatabase &db_;
    const FlashInfo *flash_info_;
    static const std::map<PacketType, DpError (*)(flash::FlashCmdPkt &pkt)> kPacketHandlerMap;
};
}  // namespace dp