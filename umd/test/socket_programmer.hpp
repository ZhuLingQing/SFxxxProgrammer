#ifndef SOCKET_PROGRAMMER_HPP
#define SOCKET_PROGRAMMER_HPP

#include <arpa/inet.h>
#include <unistd.h>

#include <cstdlib>  // getenv

#include "flash_info.pb.h"  // protobuf generated by protoc

#include "dp_config.h"
#include "dp_error.h"
#include "dp_logging.hpp"
#include "dp_type.h"
#include "flash_database.hpp"
#include "programmer.hpp"

using FlashDatabase = dp::FlashDatabase;
using FlashInfo = dp::FlashInfo;
using PacketType = flash::PacketType;

namespace dp
{
class SktProgInterface : public ProgrammerInterface
{
   public:
    SktProgInterface(void *handler) : ProgrammerInterface(handler)
    {
        skt_port_ = static_cast<int>(reinterpret_cast<long>(handler));

        skt_fd_ = socket(AF_INET, SOCK_STREAM, 0);

        sockaddr_in serverAddress{};
        serverAddress.sin_family = AF_INET;
        serverAddress.sin_port = htons(skt_port_);  // 服务器端口
        inet_pton(AF_INET, "127.0.0.1", &serverAddress.sin_addr);
        if (connect(skt_fd_, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1)
        {
            DP_LOG(FATAL) << "Failed to connect to server\n";
            close(skt_fd_);
        }
    }
    ~SktProgInterface() { close(skt_fd_); }

    DpError PowerOn() noexcept override { return Send(flash::kAttrPowerOn) == 0 ? kSc : kHardwareUnsupported; }
    DpError PowerOff() noexcept override { return Send(flash::kAttrPowerOff) == 0 ? kSc : kHardwareUnsupported; }
    int getPowerConfig(DevPowerChan chan) noexcept override
    {
        uint64_t attribute = 0;
        int r = Send(flash::kAttrGetPowerConfig);
        if (r) return r;
        return Read(flash::kAttrGetPowerConfig, attribute) == 0 ? kSc : kHardwareUnsupported;
    }
    DpError PowerConfig(DevPowerChan chan, int mvolt) noexcept override
    {
        return Send(flash::kAttrPowerConfig, mvolt) == 0 ? kSc : kHardwareUnsupported;
    }
    DpError TransferIn(uint8_t *data, size_t size, cs_pin_state_e cs = kCsHigh) noexcept
    {
        std::vector<uint8_t> byte_vct;
        int r = Send(flash::kCtrlIn, size, cs == kCsKeepLow ? false : true);
        if (r) return kHardwareUnsupported;
        r = Read(flash::kCtrlIn, byte_vct);
        if (r) return kHardwareUnsupported;
        memcpy(data, byte_vct.data(), size);
        return kSc;
    }
    DpError TransferOut(const uint8_t *data, size_t size, cs_pin_state_e cs = kCsHigh) noexcept
    {
        std::vector<uint8_t> byte_vct(data, data + size);
        int r = Send(flash::kCtrlOut, size, cs == kCsKeepLow ? false : true, &byte_vct);
        if (r) return kHardwareUnsupported;
        return kSc;
    }

   protected:
    DpError ShutDown() noexcept override { return Send(flash::kAttrShutDown) == 0 ? kSc : kHardwareUnsupported; }

   private:
    int Send(PacketType type, uint64_t attribute = 0, bool cs = true, std::vector<uint8_t> *data = nullptr)
    {
        flash::FlashCmdPkt pkt;
        pkt.set_type(type);
        if (data && data->size())
        {
            std::string byte_string;
            byte_string.assign(data->begin(), data->end());
            pkt.set_data(byte_string);
        }
        pkt.set_attribute(attribute);
        pkt.set_cs(cs);

        std::string serializedData;
        pkt.SerializeToString(&serializedData);

        uint32_t dataLength = htonl(serializedData.size());
        send(skt_fd_, &dataLength, sizeof(dataLength), 0);

        send(skt_fd_, serializedData.data(), serializedData.size(), 0);
        return 0;
    }
    int Read(PacketType type, uint64_t &attribute)
    {
        uint32_t dataLength;
        recv(skt_fd_, &dataLength, sizeof(dataLength), 0);
        dataLength = ntohl(dataLength);  // 转换字节序

        char buffer[kMaxBufferSize];
        recv(skt_fd_, buffer, dataLength, 0);

        flash::FlashCmdPkt pkt;
        if (pkt.ParseFromArray(buffer, dataLength))
        {
            if (type != pkt.type())
            {
                DP_LOG(ERROR) << "Packet type mismatch";
                return -1;
            }
            attribute = pkt.attribute();
            return 0;
        }
        else
        {
            DP_LOG(ERROR) << "Failed to parse Protobuf data";
            return -1;
        }
    }
    int Read(PacketType type, std::vector<uint8_t> &data)
    {
        uint32_t dataLength;
        recv(skt_fd_, &dataLength, sizeof(dataLength), 0);
        dataLength = ntohl(dataLength);  // 转换字节序

        char buffer[kMaxBufferSize];
        recv(skt_fd_, buffer, dataLength, 0);

        flash::FlashCmdPkt pkt;
        if (pkt.ParseFromArray(buffer, dataLength))
        {
            if (type != pkt.type())
            {
                DP_LOG(ERROR) << "Packet type mismatch";
                return -1;
            }
            std::string byte_string = pkt.data();
            data = std::vector<uint8_t>(byte_string.begin(), byte_string.end());
            return 0;
        }
        else
        {
            DP_LOG(ERROR) << "Failed to parse Protobuf data";
            return -1;
        }
    }
    int skt_port_;
    int skt_fd_;
    static const size_t kMaxBufferSize = CONFIG_PROTO_BUFFER_SIZE;
};

class SktProgrammer : public Programmer
{
   public:
    SktProgrammer(const std::string &db_file, long handler = 0x80) : Programmer(db_file)
    {
        prog_interface_ = std::shared_ptr<SktProgInterface>(new SktProgInterface(reinterpret_cast<void *>(handler)));
    }

   private:
    uint32_t CommonIdentifier(uint8_t cmd, uint8_t size) override
    {
        if (prog_interface_->getPowerConfig(kPwrVcc) < 3000) return 0;
        return Programmer::CommonIdentifier(cmd, size);
    }
};
}  // namespace dp

#endif  // #ifndef PROGRAMMER_HPP